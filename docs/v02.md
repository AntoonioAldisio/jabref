# Testes de unidade da classe PdfAnnotationImporter

## 1. Introdu√ß√£o

<p align = "justify">
O diretorio para encontrar a classe √© o seguinte:
</p>
    /src/main/java/org/jabref/logic/pdf/

<p align = "justify">
Essa classe tem com objetivo de importar as  anota√ß≈çes dentro do PDF.
</p>


## 2. Tabelas das decis√µes/condi√ß√µes

<center>

|ID | Condi√ß√£o| Situa√ß√£o para True| Situa√ß√£o para False|
|:--:|:--:|:--:|:--:|
| 01 | !validatePath(path)| Ter um path v√°lido | N√£o ter um path v√°lido| 
| 02 | !isSupportedAnnotationType(annotation)| n√£o ter uma anota√ß√£o v√°lida| Ter uma anota√ß√£o v√°lida| 
| 03 | FileAnnotationType.isMarkedFileAnnotationType(annotation.getSubtype())| Existir uma anota√ß√£o| N√£o existir uma anota√ß√£o | 
| 04 | (fileAnnotation.getContent() != null) && !fileAnnotation.getContent().isEmpty()| Tem uma anota√ß√£o e ela est√° vazia | N√£o tem uma anota√ß√£o e ela n√£o est√° vazia | 
| 05 | annotation.getSubtype() == null| Ter uma anota√ß√£o vazia| Ter uma anota√ß√£o prenchida| 
| 06 | "Link".equals(annotation.getSubtype()) || "Widget".equals(annotation.getSubtype())| Ter uma anota√ß√£o que tenha link ou ter uma anota√ß√£o Widget| N√£o ter uma anota√ß√£o que tenha link ou n√£o ter uma anota√ß√£o Widget|
| 07 | !Arrays.asList(FileAnnotationType.values()).contains(FileAnnotationType.valueOf(annotation.getSubtype()))| N√£o ter a lista de anota√ß√£o vazia | Ter a lista de anota√ß√£o vazia |
| 08 | annotationBelongingToMarking.getAnnotationType().isLinkedFileAnnotationType()| Criar uma marca na anota√ß√£o  | N√£o criar uma marca na anota√ß√£o| 
| 09 | !path.toString().toLowerCase(Locale.ROOT).endsWith(".pdf")| Arquivo em formato PDF | N√£o em outro formatos| 
| 10 | !Files.exists(path)| N√£o existir arquivo| Existe o arquivo |
| 11 | !Files.isRegularFile(path) || !Files.isReadable(path)| N√£o tem formato desejado ou n√£o conseguiu ler informa√ß≈çes dentro da anota√ß√£o | Tem formato desejado ou conseguiu ler informa√ß≈çes dentro da anota√ß√£o | 

</center>



## 3. C√≥digo 

### 3.1 C√≥digo de Produ√ß√£o 

    public class PdfAnnotationImporter implements AnnotationImporter {

        private static final Logger LOGGER = LoggerFactory.getLogger(PdfAnnotationImporter.class);

        /**
        * Imports the comments from a pdf specified by its path
        *
        * @param path a path to a pdf
        * @return a list with the all the annotations found in the file of the path
        */
        @Override
        public List<FileAnnotation> importAnnotations(final Path path) {

            if (!validatePath(path)) {
                // Path could not be validated, return default result
                return Collections.emptyList();
            }

            List<FileAnnotation> annotationsList = new LinkedList<>();
            try (PDDocument document = PDDocument.load(path.toFile())) {
                PDPageTree pdfPages = document.getDocumentCatalog().getPages();
                for (int pageIndex = 0; pageIndex < pdfPages.getCount(); pageIndex++) {
                    PDPage page = pdfPages.get(pageIndex);
                    for (PDAnnotation annotation : page.getAnnotations()) {
                        if (!isSupportedAnnotationType(annotation)) {
                            continue;
                        }

                        if (FileAnnotationType.isMarkedFileAnnotationType(annotation.getSubtype())) {
                            annotationsList.add(createMarkedAnnotations(pageIndex, page, annotation));
                        } else {
                            FileAnnotation fileAnnotation = new FileAnnotation(annotation, pageIndex + 1);
                            if ((fileAnnotation.getContent() != null) && !fileAnnotation.getContent().isEmpty()) {
                                annotationsList.add(fileAnnotation);
                            }
                        }
                    }
                }
            } catch (IOException e) {
                LOGGER.error(String.format("Failed to read file '%s'.", path), e);
            }
            return annotationsList;
        }

        private boolean isSupportedAnnotationType(PDAnnotation annotation) {
            if (annotation.getSubtype() == null) {
                return false;
            }
            if ("Link".equals(annotation.getSubtype()) || "Widget".equals(annotation.getSubtype())) {
                LOGGER.debug(annotation.getSubtype() + " is excluded from the supported file annotations");
                return false;
            }
            try {
                if (!Arrays.asList(FileAnnotationType.values()).contains(FileAnnotationType.valueOf(annotation.getSubtype()))) {
                    return false;
                }
            } catch (IllegalArgumentException e) {
                LOGGER.debug(String.format("Could not parse the FileAnnotation %s into any known FileAnnotationType. It was %s!", annotation, annotation.getSubtype()));
            }
            return true;
        }

        private FileAnnotation createMarkedAnnotations(int pageIndex, PDPage page, PDAnnotation annotation) {
            FileAnnotation annotationBelongingToMarking = new FileAnnotation(
                    annotation.getCOSObject().getString(COSName.T), FileAnnotation.extractModifiedTime(annotation.getModifiedDate()),
                    pageIndex + 1, annotation.getContents(), FileAnnotationType.valueOf(annotation.getSubtype().toUpperCase(Locale.ROOT)), Optional.empty());

            if (annotationBelongingToMarking.getAnnotationType().isLinkedFileAnnotationType()) {
                try {
                    COSArray boundingBoxes = (COSArray) annotation.getCOSObject().getDictionaryObject(COSName.getPDFName("QuadPoints"));
                    annotation.setContents(new TextExtractor(page, boundingBoxes).extractMarkedText());
                } catch (IOException e) {
                    annotation.setContents("JabRef: Could not extract any marked text!");
                }
            }

            // Marked text that has a sticky note on it should be linked to the sticky note
            return new FileAnnotation(annotation, pageIndex + 1, annotationBelongingToMarking);
        }

        private boolean validatePath(Path path) {
            Objects.requireNonNull(path);

            if (!path.toString().toLowerCase(Locale.ROOT).endsWith(".pdf")) {
                LOGGER.warn(String.format("File '%s' does not end with .pdf!", path));
                return false;
            }

            if (!Files.exists(path)) {
                LOGGER.warn(String.format("File '%s' does not exist!", path));
                return false;
            }

            if (!Files.isRegularFile(path) || !Files.isReadable(path)) {
                LOGGER.warn(String.format("File '%s' is not readable!", path));
                return false;
            }

            return true;
        }
    }


### 3.2 C√≥digo de Teste 

    package org.jabref.logic.pdf;

    import java.nio.file.Path;
    import java.time.LocalDateTime;
    import java.util.Collections;
    import java.util.Optional;

    import org.jabref.model.pdf.FileAnnotation;
    import org.jabref.model.pdf.FileAnnotationType;

    import org.junit.jupiter.api.Test;

    import static org.junit.jupiter.api.Assertions.assertEquals;

    public class PdfAnnotationImporterTest {

        private final AnnotationImporter importer = new PdfAnnotationImporter();

        @Test
        public void invalidPath() {
            assertEquals(Collections.emptyList(), importer.importAnnotations(Path.of("/asdf/does/not/exist.pdf")));
        }

        @Test
        public void invalidDirectory() {
            assertEquals(Collections.emptyList(), importer.importAnnotations(Path.of("src/test/resources/pdfs")));
        }

        @Test
        public void invalidDocumentType() {
            assertEquals(Collections.emptyList(), importer.importAnnotations(Path.of("src/test/resources/pdfs/write-protected.docx")));
        }

        @Test
        public void noAnnotationsWriteProtected() {
            assertEquals(Collections.emptyList(), importer.importAnnotations(Path.of("src/test/resources/pdfs/write-protected.pdf")));
        }

        @Test
        public void noAnnotationsEncrypted() {
            assertEquals(Collections.emptyList(), importer.importAnnotations(Path.of("src/test/resources/pdfs/encrypted.pdf")));
        }

        @Test
        public void twoAnnotationsThesisExample() {
            assertEquals(2, importer.importAnnotations(Path.of("src/test/resources/pdfs/thesis-example.pdf")).size());
        }

        @Test
        public void noAnnotationsMinimal() {
            assertEquals(Collections.emptyList(), importer.importAnnotations(Path.of("src/test/resources/pdfs/minimal.pdf")));
        }

        @Test
        public void inlineNoteMinimal() {
            final FileAnnotation expected = new FileAnnotation("Linus Dietz", LocalDateTime.of(2017, 3, 12, 20, 25), 1,
                    "inline note annotation", FileAnnotationType.FREETEXT, Optional.empty());

            assertEquals(Collections.singletonList(expected),
                    importer.importAnnotations(Path.of("src/test/resources/pdfs/minimal-inlinenote.pdf")));
        }

        @Test
        public void popupNoteMinimal() {
            final FileAnnotation expected = new FileAnnotation("Linus Dietz", LocalDateTime.of(2017, 3, 12, 20, 17, 24), 1,
                    "A simple pop-up note", FileAnnotationType.TEXT, Optional.empty());

            assertEquals(Collections.singletonList(expected),
                    importer.importAnnotations(Path.of("src/test/resources/pdfs/minimal-popup.pdf")));
        }

        @Test
        public void highlightMinimalFoxit() {
            final FileAnnotation expectedLinkedAnnotation = new FileAnnotation("lynyus", LocalDateTime.of(2017, 5, 31, 15, 16, 1), 1,
                    "this is a foxit highlight", FileAnnotationType.HIGHLIGHT, Optional.empty());
            final FileAnnotation expected = new FileAnnotation("lynyus", LocalDateTime.of(2017, 5, 31, 15, 16, 1), 1,
                    "Hello", FileAnnotationType.HIGHLIGHT, Optional.of(expectedLinkedAnnotation));
            assertEquals(Collections.singletonList(expected),
                    importer.importAnnotations(Path.of("src/test/resources/pdfs/minimal-foxithighlight.pdf")));
        }

        @Test
        public void highlightNoNoteMinimal() {
            final FileAnnotation expectedLinkedAnnotation = new FileAnnotation("Linus Dietz", LocalDateTime.of(2017, 3, 12, 20, 28, 39), 1,
                    "", FileAnnotationType.HIGHLIGHT, Optional.empty());
            final FileAnnotation expected = new FileAnnotation("Linus Dietz", LocalDateTime.of(2017, 3, 12, 20, 28, 39), 1,
                    "World", FileAnnotationType.HIGHLIGHT, Optional.of(expectedLinkedAnnotation));

            assertEquals(Collections.singletonList(expected),
                    importer.importAnnotations(Path.of("src/test/resources/pdfs/minimal-highlight-no-note.pdf")));
        }

        @Test
        public void squigglyWithNoteMinimal() {
            final FileAnnotation expectedLinkedAnnotation = new FileAnnotation("lynyus", LocalDateTime.of(2017, 6, 1, 2, 40, 25), 1,
                    "Squiggly note", FileAnnotationType.SQUIGGLY, Optional.empty());
            final FileAnnotation expected = new FileAnnotation("lynyus", LocalDateTime.of(2017, 6, 1, 2, 40, 25), 1,
                    "ello", FileAnnotationType.SQUIGGLY, Optional.of(expectedLinkedAnnotation));

            assertEquals(Collections.singletonList(expected),
                    importer.importAnnotations(Path.of("src/test/resources/pdfs/minimal-squiggly.pdf")));
        }

        @Test
        public void strikeoutWithNoteMinimal() {
            final FileAnnotation expectedLinkedAnnotation = new FileAnnotation("lynyus", LocalDateTime.of(2017, 6, 1, 13, 2, 3), 1,
                    "striked out", FileAnnotationType.STRIKEOUT, Optional.empty());
            final FileAnnotation expected = new FileAnnotation("lynyus", LocalDateTime.of(2017, 6, 1, 13, 2, 3), 1,
                    "World", FileAnnotationType.STRIKEOUT, Optional.of(expectedLinkedAnnotation));

            assertEquals(Collections.singletonList(expected),
                    importer.importAnnotations(Path.of("src/test/resources/pdfs/minimal-strikeout.pdf")));
        }

        @Test
        public void highlightWithNoteMinimal() {
            final FileAnnotation expectedLinkedAnnotation = new FileAnnotation("Linus Dietz", LocalDateTime.of(2017, 3, 12, 20, 32, 2), 1,
                    "linked note to highlight", FileAnnotationType.HIGHLIGHT, Optional.empty());
            final FileAnnotation expected = new FileAnnotation("Linus Dietz", LocalDateTime.of(2017, 3, 12, 20, 32, 2), 1,
                    "World", FileAnnotationType.HIGHLIGHT, Optional.of(expectedLinkedAnnotation));

            assertEquals(Collections.singletonList(expected),
                    importer.importAnnotations(Path.of("src/test/resources/pdfs/minimal-highlight-with-note.pdf")));
        }

        @Test
        public void underlineWithNoteMinimal() {
            final FileAnnotation expectedLinkedAnnotation = new FileAnnotation("Linus Dietz", LocalDateTime.of(2017, 3, 12, 20, 36, 9), 1,
                    "underlined", FileAnnotationType.UNDERLINE, Optional.empty());
            final FileAnnotation expected = new FileAnnotation("Linus Dietz", LocalDateTime.of(2017, 3, 12, 20, 36, 9), 1,
                    "Hello", FileAnnotationType.UNDERLINE, Optional.of(expectedLinkedAnnotation));

            assertEquals(Collections.singletonList(expected),
                    importer.importAnnotations(Path.of("src/test/resources/pdfs/minimal-underline.pdf")));
        }

        @Test
        public void polygonNoNoteMinimal() {
            final FileAnnotation expected = new FileAnnotation("Linus Dietz", LocalDateTime.of(2017, 3, 16, 9, 21, 1), 1,
                    "polygon annotation", FileAnnotationType.POLYGON, Optional.empty());

            assertEquals(Collections.singletonList(expected),
                    importer.importAnnotations(Path.of("src/test/resources/pdfs/minimal-polygon.pdf")));
        }

        // Teste proposto por Ant√¥nio Aldisio
        // Verificar se abre arquivo TXT
        @Test
        public void invalidDocumentTypeTXT() {
            assertEquals(Collections.emptyList(), importer.importAnnotations(Path.of("src/test/resources/pdfs/teste.txt")));
        }
        // Verificar se ele consegue ler alguma Emoji
        @Test
        public void highlightMinimalFoxitEMOJ() {
            final FileAnnotation expectedLinkedAnnotation = new FileAnnotation("lynyus", LocalDateTime.of(2017, 5, 31, 15, 16, 1), 1,
                    "üòÇ, üòÉ, üßòüèª‚Äç‚ôÇÔ∏è, üåç, üçû, üöó, üìû, üéâ, ‚ù§Ô∏è, üçÜ", FileAnnotationType.HIGHLIGHT, Optional.empty());
            final FileAnnotation expected = new FileAnnotation("lynyus", LocalDateTime.of(2017, 5, 31, 15, 16, 1), 1,
                    "Hello", FileAnnotationType.HIGHLIGHT, Optional.of(expectedLinkedAnnotation));
            assertEquals(Collections.singletonList(expected),
                    importer.importAnnotations(Path.of("src/test/resources/pdfs/minimal-emoji.pdf")));
        }
    }




## 4. Resultados

### 4.1 Resultados dos Testes JabRef


<p align = "justify">
Na figura 01 temos o resultado dos testes da classe PdfAnnotationImporter. Podemos observar que dois testes n√£o passaram. O primeiro teste que n√£o passou foi produzido pela JabRef e ele errou, pois alterei o coment√°rio esperado. Ent√£o esse teste j√° era esperado em n√£o passar. J√° o segundo teste foi projetado por mim e ser√° descuitdo logo adiante.
</p>

<center>

<img width="1000px" src="../images/TesteClasse.png" alt="Teste">
<figcaption>Figura 01 - Resultado dos teste da classe PdfAnnotationImporter </figcaption> 

</center>

### 4.2 Resultados dos meus Testes

<p align = "justify">
Para essa etapa do projeto preferi executar apenas dois testes novos. Em rela√ß√£o aos ID 01 e 11. 
</p>


#### 4.2.1 Resultado do teste ID 01

<p align = "justify">
O teste do ID 01 j√° existia uma corbertura, por√©m a corbertura s√≥ verificava se n√£o abria outros formatos. Com isso, fique curioso para ver se ele n√£o executava outro tipo de formato ent√£o teste o formato .TXT. A partir da figura 02 podemos ver que o JabRef n√£o consegue abrir um texto em formato .TXT o que era j√° esperado.
</p>

<center>

<img width="1000px" src="../images/TesteTXT.png" alt="Teste">
<figcaption>Figura 02 - Resultado do Teste do ID 01</figcaption> 

</center>



#### 4.2.2 Resultado do teste ID 11



<p align = "justify">
O teste do ID 11 j√° n√£o existia uma corbertura. Altere um  <a href = "https://github.com/AntoonioAldisio/jabref/blob/main/src/test/resources/pdfs/minimal-emoji.pdf"> PDF  </a> com um coment√°rio para uma s√©rie de Emoji (üòÇ, üòÉ, üßòüèª‚Äç‚ôÇÔ∏è, üåç, üçû, üöó, üìû, üéâ, ‚ù§Ô∏è, üçÜ). A partir da figura 03 podemos ver que o teste n√£o passou. 
</p>
<p align = "justify">
N√£o entendi o motivo do teste n√£o ter passado, pelo o motivo da condi√ß√£o ser um OU, sendo necess√°rio apenas uma afirma√ß√£o ser verdadeira. O arquivo consegue ser aberto ent√£o, ou seja, j√° tenho uma condi√ßa6o verdadeira, o teste deveria ser passado j√° que Emoji n√£o √© uma linguagem n√£o comprendida pelo JabRef.
</p>


<center>

<img width="1000px" src="../images/TesteEm.png" alt="Teste">
<figcaption>Figura 03 - Resultado do Teste do ID 11</figcaption> 

</center>


## Versionamento

<center>

| Vers√£o | Data | Modifica√ß√£o | Autor |
|--|--|--|--|
| 1.0 | 05/10/2021 | Cria√ß√£o do site | Ant√¥nio Ald√≠sio |
| 2.0 | 07/10/2021 | Colocar os teste | Ant√¥nio Ald√≠sio |

</center>

