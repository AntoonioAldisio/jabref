{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Sobre o Projeto 1. Introdu\u00e7\u00e3o Reposit\u00f3rio destinado ao trabalho da mat\u00e9ria Testes de Software da Universidade de Bras\u00edlia com a professora respons\u00e1vel Elaine Venson no semestre 2021.1 2. Sobre o Software O software aberto escolhido pela a professora para desenvolvimento das atividades nesse semestre \u00e9 o JabRef \u00e9 um software de gerenciamento de refer\u00eancias e cita\u00e7\u00f5es de plataforma de c\u00f3digo aberto. Ele usa BibTeX e BibLaTeX como padr\u00e3o, portanto, \u00e9 normalmente usado para LaTeX. O nome JabRef significa Java, Alver, Batada, Reference. A vers\u00e3o original foi lan\u00e7ada em 29 de novembro de 2003. 3.Integrante Foto Nome Github email Antonio Ald\u00edsio AntoonioAldisio aldisiofilho@gmail.com Versionamento Vers\u00e3o Data Modifica\u00e7\u00e3o Autor 1.0 05/10/2021 Cria\u00e7\u00e3o do site Ant\u00f4nio Ald\u00edsio","title":"Sobre"},{"location":"#sobre-o-projeto","text":"","title":"Sobre o Projeto"},{"location":"#1-introducao","text":"Reposit\u00f3rio destinado ao trabalho da mat\u00e9ria Testes de Software da Universidade de Bras\u00edlia com a professora respons\u00e1vel Elaine Venson no semestre 2021.1","title":"1. Introdu\u00e7\u00e3o"},{"location":"#2-sobre-o-software","text":"O software aberto escolhido pela a professora para desenvolvimento das atividades nesse semestre \u00e9 o JabRef \u00e9 um software de gerenciamento de refer\u00eancias e cita\u00e7\u00f5es de plataforma de c\u00f3digo aberto. Ele usa BibTeX e BibLaTeX como padr\u00e3o, portanto, \u00e9 normalmente usado para LaTeX. O nome JabRef significa Java, Alver, Batada, Reference. A vers\u00e3o original foi lan\u00e7ada em 29 de novembro de 2003.","title":"2. Sobre o Software"},{"location":"#3integrante","text":"Foto Nome Github email Antonio Ald\u00edsio AntoonioAldisio aldisiofilho@gmail.com","title":"3.Integrante"},{"location":"#versionamento","text":"Vers\u00e3o Data Modifica\u00e7\u00e3o Autor 1.0 05/10/2021 Cria\u00e7\u00e3o do site Ant\u00f4nio Ald\u00edsio","title":"Versionamento"},{"location":"conf/","text":"Configura\u00e7\u00f5es 1. Especifica\u00e7\u00e3o da m\u00e1quina de teste A m\u00e1quina utilizada para realiza\u00e7\u00e3o dos testes \u00e9 um MacBook Pro 2017 com processador I5 com mem\u00f3ria RAM de 8 Giga. A IDE escolhida foi a IntelliJ 2021.2. 2. Configura\u00e7\u00f5es necess\u00e1rias O primeiro passo foi baixar o JDK 16 direto da orcale no formato .dmg . Ap\u00f3s isso, tem que se baixar o JAVAFX 16 - jmod . Com o arquivo baixado \u00e9 necess\u00e1rio descompactar e colar os os arquivos dentro da pasta /Library/Java/JavaVirtualMachines/jdk-16.0.1.jdk/Contents/Home/jmod/ Ap\u00f3s, desta etapa pode seguir o guia disponibilizado pelo JabRef de configura\u00e7\u00e3o de ambiente local, que pode ser acessado atrav\u00e9s do link . Versionamento Vers\u00e3o Data Modifica\u00e7\u00e3o Autor 1.0 05/10/2021 Cria\u00e7\u00e3o do site Ant\u00f4nio Ald\u00edsio","title":"Configura\u00e7\u014des"},{"location":"conf/#configuracoes","text":"","title":"Configura\u00e7\u00f5es"},{"location":"conf/#1-especificacao-da-maquina-de-teste","text":"A m\u00e1quina utilizada para realiza\u00e7\u00e3o dos testes \u00e9 um MacBook Pro 2017 com processador I5 com mem\u00f3ria RAM de 8 Giga. A IDE escolhida foi a IntelliJ 2021.2.","title":"1. Especifica\u00e7\u00e3o da m\u00e1quina de teste"},{"location":"conf/#2-configuracoes-necessarias","text":"O primeiro passo foi baixar o JDK 16 direto da orcale no formato .dmg . Ap\u00f3s isso, tem que se baixar o JAVAFX 16 - jmod . Com o arquivo baixado \u00e9 necess\u00e1rio descompactar e colar os os arquivos dentro da pasta /Library/Java/JavaVirtualMachines/jdk-16.0.1.jdk/Contents/Home/jmod/ Ap\u00f3s, desta etapa pode seguir o guia disponibilizado pelo JabRef de configura\u00e7\u00e3o de ambiente local, que pode ser acessado atrav\u00e9s do link .","title":"2. Configura\u00e7\u00f5es necess\u00e1rias"},{"location":"conf/#versionamento","text":"Vers\u00e3o Data Modifica\u00e7\u00e3o Autor 1.0 05/10/2021 Cria\u00e7\u00e3o do site Ant\u00f4nio Ald\u00edsio","title":"Versionamento"},{"location":"v01/","text":"Testes de unidade 1. Teste disponibilizados pelo JabRef O c\u00f3digo do JabRef j\u00e1 tem teste desenvolvidos anteriormente. Que s\u00e3o 7480 ao todo. Em uma execu\u00e7\u00e3o no IntelliJ optive 7459 testes aprovados e 21 ignorados (skip), como pode ser visto na figura 01. Com um tempo de execu\u00e7\u00e3o de 5 min 2 sec. Figura 01 - Teste do JabRef (Melhorar imagem ) Versionamento Vers\u00e3o Data Modifica\u00e7\u00e3o Autor 1.0 05/10/2021 Cria\u00e7\u00e3o do site Ant\u00f4nio Ald\u00edsio","title":"Teste de unidade do JabRef"},{"location":"v01/#testes-de-unidade","text":"","title":"Testes de unidade"},{"location":"v01/#1-teste-disponibilizados-pelo-jabref","text":"O c\u00f3digo do JabRef j\u00e1 tem teste desenvolvidos anteriormente. Que s\u00e3o 7480 ao todo. Em uma execu\u00e7\u00e3o no IntelliJ optive 7459 testes aprovados e 21 ignorados (skip), como pode ser visto na figura 01. Com um tempo de execu\u00e7\u00e3o de 5 min 2 sec. Figura 01 - Teste do JabRef (Melhorar imagem )","title":"1. Teste disponibilizados pelo JabRef"},{"location":"v01/#versionamento","text":"Vers\u00e3o Data Modifica\u00e7\u00e3o Autor 1.0 05/10/2021 Cria\u00e7\u00e3o do site Ant\u00f4nio Ald\u00edsio","title":"Versionamento"},{"location":"v02/","text":"Testes de unidade da classe PdfAnnotationImporter 1. Introdu\u00e7\u00e3o O diretorio para encontrar a classe \u00e9 o seguinte: /src/main/java/org/jabref/logic/pdf/ Essa classe tem com objetivo de importar as anota\u00e7\u014des dentro do PDF. 2. Tabelas das decis\u00f5es/condi\u00e7\u00f5es ID Condi\u00e7\u00e3o Situa\u00e7\u00e3o para True Situa\u00e7\u00e3o para False 01 !validatePath(path) Ter um path v\u00e1lido N\u00e3o ter um path v\u00e1lido 02 !isSupportedAnnotationType(annotation) n\u00e3o ter uma anota\u00e7\u00e3o v\u00e1lida Ter uma anota\u00e7\u00e3o v\u00e1lida 03 FileAnnotationType.isMarkedFileAnnotationType(annotation.getSubtype()) Existir uma anota\u00e7\u00e3o N\u00e3o existir uma anota\u00e7\u00e3o 04 (fileAnnotation.getContent() != null) && !fileAnnotation.getContent().isEmpty() Tem uma anota\u00e7\u00e3o e ela est\u00e1 vazia N\u00e3o tem uma anota\u00e7\u00e3o e ela n\u00e3o est\u00e1 vazia 05 annotation.getSubtype() == null Ter uma anota\u00e7\u00e3o vazia Ter uma anota\u00e7\u00e3o prenchida 06 \"Link\".equals(annotation.getSubtype()) \"Widget\".equals(annotation.getSubtype()) 07 !Arrays.asList(FileAnnotationType.values()).contains(FileAnnotationType.valueOf(annotation.getSubtype())) N\u00e3o ter a lista de anota\u00e7\u00e3o vazia Ter a lista de anota\u00e7\u00e3o vazia 08 annotationBelongingToMarking.getAnnotationType().isLinkedFileAnnotationType() Criar uma marca na anota\u00e7\u00e3o N\u00e3o criar uma marca na anota\u00e7\u00e3o 09 !path.toString().toLowerCase(Locale.ROOT).endsWith(\".pdf\") Arquivo em formato PDF N\u00e3o em outro formatos 10 !Files.exists(path) N\u00e3o existir arquivo Existe o arquivo 11 !Files.isRegularFile(path) !Files.isReadable(path) 3. C\u00f3digo 3.1 C\u00f3digo de Produ\u00e7\u00e3o public class PdfAnnotationImporter implements AnnotationImporter { private static final Logger LOGGER = LoggerFactory.getLogger(PdfAnnotationImporter.class); /** * Imports the comments from a pdf specified by its path * * @param path a path to a pdf * @return a list with the all the annotations found in the file of the path */ @Override public List<FileAnnotation> importAnnotations(final Path path) { if (!validatePath(path)) { // Path could not be validated, return default result return Collections.emptyList(); } List<FileAnnotation> annotationsList = new LinkedList<>(); try (PDDocument document = PDDocument.load(path.toFile())) { PDPageTree pdfPages = document.getDocumentCatalog().getPages(); for (int pageIndex = 0; pageIndex < pdfPages.getCount(); pageIndex++) { PDPage page = pdfPages.get(pageIndex); for (PDAnnotation annotation : page.getAnnotations()) { if (!isSupportedAnnotationType(annotation)) { continue; } if (FileAnnotationType.isMarkedFileAnnotationType(annotation.getSubtype())) { annotationsList.add(createMarkedAnnotations(pageIndex, page, annotation)); } else { FileAnnotation fileAnnotation = new FileAnnotation(annotation, pageIndex + 1); if ((fileAnnotation.getContent() != null) && !fileAnnotation.getContent().isEmpty()) { annotationsList.add(fileAnnotation); } } } } } catch (IOException e) { LOGGER.error(String.format(\"Failed to read file '%s'.\", path), e); } return annotationsList; } private boolean isSupportedAnnotationType(PDAnnotation annotation) { if (annotation.getSubtype() == null) { return false; } if (\"Link\".equals(annotation.getSubtype()) || \"Widget\".equals(annotation.getSubtype())) { LOGGER.debug(annotation.getSubtype() + \" is excluded from the supported file annotations\"); return false; } try { if (!Arrays.asList(FileAnnotationType.values()).contains(FileAnnotationType.valueOf(annotation.getSubtype()))) { return false; } } catch (IllegalArgumentException e) { LOGGER.debug(String.format(\"Could not parse the FileAnnotation %s into any known FileAnnotationType. It was %s!\", annotation, annotation.getSubtype())); } return true; } private FileAnnotation createMarkedAnnotations(int pageIndex, PDPage page, PDAnnotation annotation) { FileAnnotation annotationBelongingToMarking = new FileAnnotation( annotation.getCOSObject().getString(COSName.T), FileAnnotation.extractModifiedTime(annotation.getModifiedDate()), pageIndex + 1, annotation.getContents(), FileAnnotationType.valueOf(annotation.getSubtype().toUpperCase(Locale.ROOT)), Optional.empty()); if (annotationBelongingToMarking.getAnnotationType().isLinkedFileAnnotationType()) { try { COSArray boundingBoxes = (COSArray) annotation.getCOSObject().getDictionaryObject(COSName.getPDFName(\"QuadPoints\")); annotation.setContents(new TextExtractor(page, boundingBoxes).extractMarkedText()); } catch (IOException e) { annotation.setContents(\"JabRef: Could not extract any marked text!\"); } } // Marked text that has a sticky note on it should be linked to the sticky note return new FileAnnotation(annotation, pageIndex + 1, annotationBelongingToMarking); } private boolean validatePath(Path path) { Objects.requireNonNull(path); if (!path.toString().toLowerCase(Locale.ROOT).endsWith(\".pdf\")) { LOGGER.warn(String.format(\"File '%s' does not end with .pdf!\", path)); return false; } if (!Files.exists(path)) { LOGGER.warn(String.format(\"File '%s' does not exist!\", path)); return false; } if (!Files.isRegularFile(path) || !Files.isReadable(path)) { LOGGER.warn(String.format(\"File '%s' is not readable!\", path)); return false; } return true; } } 3.2 C\u00f3digo de Teste package org.jabref.logic.pdf; import java.nio.file.Path; import java.time.LocalDateTime; import java.util.Collections; import java.util.Optional; import org.jabref.model.pdf.FileAnnotation; import org.jabref.model.pdf.FileAnnotationType; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class PdfAnnotationImporterTest { private final AnnotationImporter importer = new PdfAnnotationImporter(); @Test public void invalidPath() { assertEquals(Collections.emptyList(), importer.importAnnotations(Path.of(\"/asdf/does/not/exist.pdf\"))); } @Test public void invalidDirectory() { assertEquals(Collections.emptyList(), importer.importAnnotations(Path.of(\"src/test/resources/pdfs\"))); } @Test public void invalidDocumentType() { assertEquals(Collections.emptyList(), importer.importAnnotations(Path.of(\"src/test/resources/pdfs/write-protected.docx\"))); } @Test public void noAnnotationsWriteProtected() { assertEquals(Collections.emptyList(), importer.importAnnotations(Path.of(\"src/test/resources/pdfs/write-protected.pdf\"))); } @Test public void noAnnotationsEncrypted() { assertEquals(Collections.emptyList(), importer.importAnnotations(Path.of(\"src/test/resources/pdfs/encrypted.pdf\"))); } @Test public void twoAnnotationsThesisExample() { assertEquals(2, importer.importAnnotations(Path.of(\"src/test/resources/pdfs/thesis-example.pdf\")).size()); } @Test public void noAnnotationsMinimal() { assertEquals(Collections.emptyList(), importer.importAnnotations(Path.of(\"src/test/resources/pdfs/minimal.pdf\"))); } @Test public void inlineNoteMinimal() { final FileAnnotation expected = new FileAnnotation(\"Linus Dietz\", LocalDateTime.of(2017, 3, 12, 20, 25), 1, \"inline note annotation\", FileAnnotationType.FREETEXT, Optional.empty()); assertEquals(Collections.singletonList(expected), importer.importAnnotations(Path.of(\"src/test/resources/pdfs/minimal-inlinenote.pdf\"))); } @Test public void popupNoteMinimal() { final FileAnnotation expected = new FileAnnotation(\"Linus Dietz\", LocalDateTime.of(2017, 3, 12, 20, 17, 24), 1, \"A simple pop-up note\", FileAnnotationType.TEXT, Optional.empty()); assertEquals(Collections.singletonList(expected), importer.importAnnotations(Path.of(\"src/test/resources/pdfs/minimal-popup.pdf\"))); } @Test public void highlightMinimalFoxit() { final FileAnnotation expectedLinkedAnnotation = new FileAnnotation(\"lynyus\", LocalDateTime.of(2017, 5, 31, 15, 16, 1), 1, \"this is a foxit highlight\", FileAnnotationType.HIGHLIGHT, Optional.empty()); final FileAnnotation expected = new FileAnnotation(\"lynyus\", LocalDateTime.of(2017, 5, 31, 15, 16, 1), 1, \"Hello\", FileAnnotationType.HIGHLIGHT, Optional.of(expectedLinkedAnnotation)); assertEquals(Collections.singletonList(expected), importer.importAnnotations(Path.of(\"src/test/resources/pdfs/minimal-foxithighlight.pdf\"))); } @Test public void highlightNoNoteMinimal() { final FileAnnotation expectedLinkedAnnotation = new FileAnnotation(\"Linus Dietz\", LocalDateTime.of(2017, 3, 12, 20, 28, 39), 1, \"\", FileAnnotationType.HIGHLIGHT, Optional.empty()); final FileAnnotation expected = new FileAnnotation(\"Linus Dietz\", LocalDateTime.of(2017, 3, 12, 20, 28, 39), 1, \"World\", FileAnnotationType.HIGHLIGHT, Optional.of(expectedLinkedAnnotation)); assertEquals(Collections.singletonList(expected), importer.importAnnotations(Path.of(\"src/test/resources/pdfs/minimal-highlight-no-note.pdf\"))); } @Test public void squigglyWithNoteMinimal() { final FileAnnotation expectedLinkedAnnotation = new FileAnnotation(\"lynyus\", LocalDateTime.of(2017, 6, 1, 2, 40, 25), 1, \"Squiggly note\", FileAnnotationType.SQUIGGLY, Optional.empty()); final FileAnnotation expected = new FileAnnotation(\"lynyus\", LocalDateTime.of(2017, 6, 1, 2, 40, 25), 1, \"ello\", FileAnnotationType.SQUIGGLY, Optional.of(expectedLinkedAnnotation)); assertEquals(Collections.singletonList(expected), importer.importAnnotations(Path.of(\"src/test/resources/pdfs/minimal-squiggly.pdf\"))); } @Test public void strikeoutWithNoteMinimal() { final FileAnnotation expectedLinkedAnnotation = new FileAnnotation(\"lynyus\", LocalDateTime.of(2017, 6, 1, 13, 2, 3), 1, \"striked out\", FileAnnotationType.STRIKEOUT, Optional.empty()); final FileAnnotation expected = new FileAnnotation(\"lynyus\", LocalDateTime.of(2017, 6, 1, 13, 2, 3), 1, \"World\", FileAnnotationType.STRIKEOUT, Optional.of(expectedLinkedAnnotation)); assertEquals(Collections.singletonList(expected), importer.importAnnotations(Path.of(\"src/test/resources/pdfs/minimal-strikeout.pdf\"))); } @Test public void highlightWithNoteMinimal() { final FileAnnotation expectedLinkedAnnotation = new FileAnnotation(\"Linus Dietz\", LocalDateTime.of(2017, 3, 12, 20, 32, 2), 1, \"linked note to highlight\", FileAnnotationType.HIGHLIGHT, Optional.empty()); final FileAnnotation expected = new FileAnnotation(\"Linus Dietz\", LocalDateTime.of(2017, 3, 12, 20, 32, 2), 1, \"World\", FileAnnotationType.HIGHLIGHT, Optional.of(expectedLinkedAnnotation)); assertEquals(Collections.singletonList(expected), importer.importAnnotations(Path.of(\"src/test/resources/pdfs/minimal-highlight-with-note.pdf\"))); } @Test public void underlineWithNoteMinimal() { final FileAnnotation expectedLinkedAnnotation = new FileAnnotation(\"Linus Dietz\", LocalDateTime.of(2017, 3, 12, 20, 36, 9), 1, \"underlined\", FileAnnotationType.UNDERLINE, Optional.empty()); final FileAnnotation expected = new FileAnnotation(\"Linus Dietz\", LocalDateTime.of(2017, 3, 12, 20, 36, 9), 1, \"Hello\", FileAnnotationType.UNDERLINE, Optional.of(expectedLinkedAnnotation)); assertEquals(Collections.singletonList(expected), importer.importAnnotations(Path.of(\"src/test/resources/pdfs/minimal-underline.pdf\"))); } @Test public void polygonNoNoteMinimal() { final FileAnnotation expected = new FileAnnotation(\"Linus Dietz\", LocalDateTime.of(2017, 3, 16, 9, 21, 1), 1, \"polygon annotation\", FileAnnotationType.POLYGON, Optional.empty()); assertEquals(Collections.singletonList(expected), importer.importAnnotations(Path.of(\"src/test/resources/pdfs/minimal-polygon.pdf\"))); } // Teste proposto por Ant\u00f4nio Aldisio // Verificar se abre arquivo TXT @Test public void invalidDocumentTypeTXT() { assertEquals(Collections.emptyList(), importer.importAnnotations(Path.of(\"src/test/resources/pdfs/teste.txt\"))); } // Verificar se ele consegue ler alguma Emoji @Test public void highlightMinimalFoxitEMOJ() { final FileAnnotation expectedLinkedAnnotation = new FileAnnotation(\"lynyus\", LocalDateTime.of(2017, 5, 31, 15, 16, 1), 1, \"\ud83d\ude02, \ud83d\ude03, \ud83e\uddd8\ud83c\udffb\u200d\u2642\ufe0f, \ud83c\udf0d, \ud83c\udf5e, \ud83d\ude97, \ud83d\udcde, \ud83c\udf89, \u2764\ufe0f, \ud83c\udf46\", FileAnnotationType.HIGHLIGHT, Optional.empty()); final FileAnnotation expected = new FileAnnotation(\"lynyus\", LocalDateTime.of(2017, 5, 31, 15, 16, 1), 1, \"Hello\", FileAnnotationType.HIGHLIGHT, Optional.of(expectedLinkedAnnotation)); assertEquals(Collections.singletonList(expected), importer.importAnnotations(Path.of(\"src/test/resources/pdfs/minimal-emoji.pdf\"))); } } 4. Resultados 4.1 Resultados dos Testes JabRef Na figura 01 temos o resultado dos testes da classe PdfAnnotationImporter. Podemos observar que dois testes n\u00e3o passaram. O primeiro teste que n\u00e3o passou foi produzido pela JabRef e ele errou, pois alterei o coment\u00e1rio esperado. Ent\u00e3o esse teste j\u00e1 era esperado em n\u00e3o passar. J\u00e1 o segundo teste foi projetado por mim e ser\u00e1 descuitdo logo adiante. Figura 01 - Resultado dos teste da classe PdfAnnotationImporter 4.2 Resultados dos meus Testes Para essa etapa do projeto preferi executar apenas dois testes novos. Em rela\u00e7\u00e3o aos ID 01 e 11. 4.2.1 Resultado do teste ID 01 O teste do ID 01 j\u00e1 existia uma corbertura, por\u00e9m a corbertura s\u00f3 verificava se n\u00e3o abria outros formatos. Com isso, fique curioso para ver se ele n\u00e3o executava outro tipo de formato ent\u00e3o teste o formato .TXT. A partir da figura 02 podemos ver que o JabRef n\u00e3o consegue abrir um texto em formato .TXT o que era j\u00e1 esperado. Figura 02 - Resultado do Teste do ID 01 4.2.2 Resultado do teste ID 11 O teste do ID 11 j\u00e1 n\u00e3o existia uma corbertura. Altere um PDF com um coment\u00e1rio para uma s\u00e9rie de Emoji (\ud83d\ude02, \ud83d\ude03, \ud83e\uddd8\ud83c\udffb\u200d\u2642\ufe0f, \ud83c\udf0d, \ud83c\udf5e, \ud83d\ude97, \ud83d\udcde, \ud83c\udf89, \u2764\ufe0f, \ud83c\udf46). A partir da figura 03 podemos ver que o teste n\u00e3o passou. N\u00e3o entendi o motivo do teste n\u00e3o ter passado, pelo o motivo da condi\u00e7\u00e3o ser um OU, sendo necess\u00e1rio apenas uma afirma\u00e7\u00e3o ser verdadeira. O arquivo consegue ser aberto ent\u00e3o, ou seja, j\u00e1 tenho uma condi\u00e7a6o verdadeira, o teste deveria ser passado j\u00e1 que Emoji n\u00e3o \u00e9 uma linguagem n\u00e3o comprendida pelo JabRef. Figura 03 - Resultado do Teste do ID 11 Versionamento Vers\u00e3o Data Modifica\u00e7\u00e3o Autor 1.0 05/10/2021 Cria\u00e7\u00e3o do site Ant\u00f4nio Ald\u00edsio 2.0 07/10/2021 Colocar os teste Ant\u00f4nio Ald\u00edsio","title":"Testes de unidade da classe PdfAnnotationImporter"},{"location":"v02/#testes-de-unidade-da-classe-pdfannotationimporter","text":"","title":"Testes de unidade da classe PdfAnnotationImporter"},{"location":"v02/#1-introducao","text":"O diretorio para encontrar a classe \u00e9 o seguinte: /src/main/java/org/jabref/logic/pdf/ Essa classe tem com objetivo de importar as anota\u00e7\u014des dentro do PDF.","title":"1. Introdu\u00e7\u00e3o"},{"location":"v02/#2-tabelas-das-decisoescondicoes","text":"ID Condi\u00e7\u00e3o Situa\u00e7\u00e3o para True Situa\u00e7\u00e3o para False 01 !validatePath(path) Ter um path v\u00e1lido N\u00e3o ter um path v\u00e1lido 02 !isSupportedAnnotationType(annotation) n\u00e3o ter uma anota\u00e7\u00e3o v\u00e1lida Ter uma anota\u00e7\u00e3o v\u00e1lida 03 FileAnnotationType.isMarkedFileAnnotationType(annotation.getSubtype()) Existir uma anota\u00e7\u00e3o N\u00e3o existir uma anota\u00e7\u00e3o 04 (fileAnnotation.getContent() != null) && !fileAnnotation.getContent().isEmpty() Tem uma anota\u00e7\u00e3o e ela est\u00e1 vazia N\u00e3o tem uma anota\u00e7\u00e3o e ela n\u00e3o est\u00e1 vazia 05 annotation.getSubtype() == null Ter uma anota\u00e7\u00e3o vazia Ter uma anota\u00e7\u00e3o prenchida 06 \"Link\".equals(annotation.getSubtype()) \"Widget\".equals(annotation.getSubtype()) 07 !Arrays.asList(FileAnnotationType.values()).contains(FileAnnotationType.valueOf(annotation.getSubtype())) N\u00e3o ter a lista de anota\u00e7\u00e3o vazia Ter a lista de anota\u00e7\u00e3o vazia 08 annotationBelongingToMarking.getAnnotationType().isLinkedFileAnnotationType() Criar uma marca na anota\u00e7\u00e3o N\u00e3o criar uma marca na anota\u00e7\u00e3o 09 !path.toString().toLowerCase(Locale.ROOT).endsWith(\".pdf\") Arquivo em formato PDF N\u00e3o em outro formatos 10 !Files.exists(path) N\u00e3o existir arquivo Existe o arquivo 11 !Files.isRegularFile(path) !Files.isReadable(path)","title":"2. Tabelas das decis\u00f5es/condi\u00e7\u00f5es"},{"location":"v02/#3-codigo","text":"","title":"3. C\u00f3digo"},{"location":"v02/#31-codigo-de-producao","text":"public class PdfAnnotationImporter implements AnnotationImporter { private static final Logger LOGGER = LoggerFactory.getLogger(PdfAnnotationImporter.class); /** * Imports the comments from a pdf specified by its path * * @param path a path to a pdf * @return a list with the all the annotations found in the file of the path */ @Override public List<FileAnnotation> importAnnotations(final Path path) { if (!validatePath(path)) { // Path could not be validated, return default result return Collections.emptyList(); } List<FileAnnotation> annotationsList = new LinkedList<>(); try (PDDocument document = PDDocument.load(path.toFile())) { PDPageTree pdfPages = document.getDocumentCatalog().getPages(); for (int pageIndex = 0; pageIndex < pdfPages.getCount(); pageIndex++) { PDPage page = pdfPages.get(pageIndex); for (PDAnnotation annotation : page.getAnnotations()) { if (!isSupportedAnnotationType(annotation)) { continue; } if (FileAnnotationType.isMarkedFileAnnotationType(annotation.getSubtype())) { annotationsList.add(createMarkedAnnotations(pageIndex, page, annotation)); } else { FileAnnotation fileAnnotation = new FileAnnotation(annotation, pageIndex + 1); if ((fileAnnotation.getContent() != null) && !fileAnnotation.getContent().isEmpty()) { annotationsList.add(fileAnnotation); } } } } } catch (IOException e) { LOGGER.error(String.format(\"Failed to read file '%s'.\", path), e); } return annotationsList; } private boolean isSupportedAnnotationType(PDAnnotation annotation) { if (annotation.getSubtype() == null) { return false; } if (\"Link\".equals(annotation.getSubtype()) || \"Widget\".equals(annotation.getSubtype())) { LOGGER.debug(annotation.getSubtype() + \" is excluded from the supported file annotations\"); return false; } try { if (!Arrays.asList(FileAnnotationType.values()).contains(FileAnnotationType.valueOf(annotation.getSubtype()))) { return false; } } catch (IllegalArgumentException e) { LOGGER.debug(String.format(\"Could not parse the FileAnnotation %s into any known FileAnnotationType. It was %s!\", annotation, annotation.getSubtype())); } return true; } private FileAnnotation createMarkedAnnotations(int pageIndex, PDPage page, PDAnnotation annotation) { FileAnnotation annotationBelongingToMarking = new FileAnnotation( annotation.getCOSObject().getString(COSName.T), FileAnnotation.extractModifiedTime(annotation.getModifiedDate()), pageIndex + 1, annotation.getContents(), FileAnnotationType.valueOf(annotation.getSubtype().toUpperCase(Locale.ROOT)), Optional.empty()); if (annotationBelongingToMarking.getAnnotationType().isLinkedFileAnnotationType()) { try { COSArray boundingBoxes = (COSArray) annotation.getCOSObject().getDictionaryObject(COSName.getPDFName(\"QuadPoints\")); annotation.setContents(new TextExtractor(page, boundingBoxes).extractMarkedText()); } catch (IOException e) { annotation.setContents(\"JabRef: Could not extract any marked text!\"); } } // Marked text that has a sticky note on it should be linked to the sticky note return new FileAnnotation(annotation, pageIndex + 1, annotationBelongingToMarking); } private boolean validatePath(Path path) { Objects.requireNonNull(path); if (!path.toString().toLowerCase(Locale.ROOT).endsWith(\".pdf\")) { LOGGER.warn(String.format(\"File '%s' does not end with .pdf!\", path)); return false; } if (!Files.exists(path)) { LOGGER.warn(String.format(\"File '%s' does not exist!\", path)); return false; } if (!Files.isRegularFile(path) || !Files.isReadable(path)) { LOGGER.warn(String.format(\"File '%s' is not readable!\", path)); return false; } return true; } }","title":"3.1 C\u00f3digo de Produ\u00e7\u00e3o"},{"location":"v02/#32-codigo-de-teste","text":"package org.jabref.logic.pdf; import java.nio.file.Path; import java.time.LocalDateTime; import java.util.Collections; import java.util.Optional; import org.jabref.model.pdf.FileAnnotation; import org.jabref.model.pdf.FileAnnotationType; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class PdfAnnotationImporterTest { private final AnnotationImporter importer = new PdfAnnotationImporter(); @Test public void invalidPath() { assertEquals(Collections.emptyList(), importer.importAnnotations(Path.of(\"/asdf/does/not/exist.pdf\"))); } @Test public void invalidDirectory() { assertEquals(Collections.emptyList(), importer.importAnnotations(Path.of(\"src/test/resources/pdfs\"))); } @Test public void invalidDocumentType() { assertEquals(Collections.emptyList(), importer.importAnnotations(Path.of(\"src/test/resources/pdfs/write-protected.docx\"))); } @Test public void noAnnotationsWriteProtected() { assertEquals(Collections.emptyList(), importer.importAnnotations(Path.of(\"src/test/resources/pdfs/write-protected.pdf\"))); } @Test public void noAnnotationsEncrypted() { assertEquals(Collections.emptyList(), importer.importAnnotations(Path.of(\"src/test/resources/pdfs/encrypted.pdf\"))); } @Test public void twoAnnotationsThesisExample() { assertEquals(2, importer.importAnnotations(Path.of(\"src/test/resources/pdfs/thesis-example.pdf\")).size()); } @Test public void noAnnotationsMinimal() { assertEquals(Collections.emptyList(), importer.importAnnotations(Path.of(\"src/test/resources/pdfs/minimal.pdf\"))); } @Test public void inlineNoteMinimal() { final FileAnnotation expected = new FileAnnotation(\"Linus Dietz\", LocalDateTime.of(2017, 3, 12, 20, 25), 1, \"inline note annotation\", FileAnnotationType.FREETEXT, Optional.empty()); assertEquals(Collections.singletonList(expected), importer.importAnnotations(Path.of(\"src/test/resources/pdfs/minimal-inlinenote.pdf\"))); } @Test public void popupNoteMinimal() { final FileAnnotation expected = new FileAnnotation(\"Linus Dietz\", LocalDateTime.of(2017, 3, 12, 20, 17, 24), 1, \"A simple pop-up note\", FileAnnotationType.TEXT, Optional.empty()); assertEquals(Collections.singletonList(expected), importer.importAnnotations(Path.of(\"src/test/resources/pdfs/minimal-popup.pdf\"))); } @Test public void highlightMinimalFoxit() { final FileAnnotation expectedLinkedAnnotation = new FileAnnotation(\"lynyus\", LocalDateTime.of(2017, 5, 31, 15, 16, 1), 1, \"this is a foxit highlight\", FileAnnotationType.HIGHLIGHT, Optional.empty()); final FileAnnotation expected = new FileAnnotation(\"lynyus\", LocalDateTime.of(2017, 5, 31, 15, 16, 1), 1, \"Hello\", FileAnnotationType.HIGHLIGHT, Optional.of(expectedLinkedAnnotation)); assertEquals(Collections.singletonList(expected), importer.importAnnotations(Path.of(\"src/test/resources/pdfs/minimal-foxithighlight.pdf\"))); } @Test public void highlightNoNoteMinimal() { final FileAnnotation expectedLinkedAnnotation = new FileAnnotation(\"Linus Dietz\", LocalDateTime.of(2017, 3, 12, 20, 28, 39), 1, \"\", FileAnnotationType.HIGHLIGHT, Optional.empty()); final FileAnnotation expected = new FileAnnotation(\"Linus Dietz\", LocalDateTime.of(2017, 3, 12, 20, 28, 39), 1, \"World\", FileAnnotationType.HIGHLIGHT, Optional.of(expectedLinkedAnnotation)); assertEquals(Collections.singletonList(expected), importer.importAnnotations(Path.of(\"src/test/resources/pdfs/minimal-highlight-no-note.pdf\"))); } @Test public void squigglyWithNoteMinimal() { final FileAnnotation expectedLinkedAnnotation = new FileAnnotation(\"lynyus\", LocalDateTime.of(2017, 6, 1, 2, 40, 25), 1, \"Squiggly note\", FileAnnotationType.SQUIGGLY, Optional.empty()); final FileAnnotation expected = new FileAnnotation(\"lynyus\", LocalDateTime.of(2017, 6, 1, 2, 40, 25), 1, \"ello\", FileAnnotationType.SQUIGGLY, Optional.of(expectedLinkedAnnotation)); assertEquals(Collections.singletonList(expected), importer.importAnnotations(Path.of(\"src/test/resources/pdfs/minimal-squiggly.pdf\"))); } @Test public void strikeoutWithNoteMinimal() { final FileAnnotation expectedLinkedAnnotation = new FileAnnotation(\"lynyus\", LocalDateTime.of(2017, 6, 1, 13, 2, 3), 1, \"striked out\", FileAnnotationType.STRIKEOUT, Optional.empty()); final FileAnnotation expected = new FileAnnotation(\"lynyus\", LocalDateTime.of(2017, 6, 1, 13, 2, 3), 1, \"World\", FileAnnotationType.STRIKEOUT, Optional.of(expectedLinkedAnnotation)); assertEquals(Collections.singletonList(expected), importer.importAnnotations(Path.of(\"src/test/resources/pdfs/minimal-strikeout.pdf\"))); } @Test public void highlightWithNoteMinimal() { final FileAnnotation expectedLinkedAnnotation = new FileAnnotation(\"Linus Dietz\", LocalDateTime.of(2017, 3, 12, 20, 32, 2), 1, \"linked note to highlight\", FileAnnotationType.HIGHLIGHT, Optional.empty()); final FileAnnotation expected = new FileAnnotation(\"Linus Dietz\", LocalDateTime.of(2017, 3, 12, 20, 32, 2), 1, \"World\", FileAnnotationType.HIGHLIGHT, Optional.of(expectedLinkedAnnotation)); assertEquals(Collections.singletonList(expected), importer.importAnnotations(Path.of(\"src/test/resources/pdfs/minimal-highlight-with-note.pdf\"))); } @Test public void underlineWithNoteMinimal() { final FileAnnotation expectedLinkedAnnotation = new FileAnnotation(\"Linus Dietz\", LocalDateTime.of(2017, 3, 12, 20, 36, 9), 1, \"underlined\", FileAnnotationType.UNDERLINE, Optional.empty()); final FileAnnotation expected = new FileAnnotation(\"Linus Dietz\", LocalDateTime.of(2017, 3, 12, 20, 36, 9), 1, \"Hello\", FileAnnotationType.UNDERLINE, Optional.of(expectedLinkedAnnotation)); assertEquals(Collections.singletonList(expected), importer.importAnnotations(Path.of(\"src/test/resources/pdfs/minimal-underline.pdf\"))); } @Test public void polygonNoNoteMinimal() { final FileAnnotation expected = new FileAnnotation(\"Linus Dietz\", LocalDateTime.of(2017, 3, 16, 9, 21, 1), 1, \"polygon annotation\", FileAnnotationType.POLYGON, Optional.empty()); assertEquals(Collections.singletonList(expected), importer.importAnnotations(Path.of(\"src/test/resources/pdfs/minimal-polygon.pdf\"))); } // Teste proposto por Ant\u00f4nio Aldisio // Verificar se abre arquivo TXT @Test public void invalidDocumentTypeTXT() { assertEquals(Collections.emptyList(), importer.importAnnotations(Path.of(\"src/test/resources/pdfs/teste.txt\"))); } // Verificar se ele consegue ler alguma Emoji @Test public void highlightMinimalFoxitEMOJ() { final FileAnnotation expectedLinkedAnnotation = new FileAnnotation(\"lynyus\", LocalDateTime.of(2017, 5, 31, 15, 16, 1), 1, \"\ud83d\ude02, \ud83d\ude03, \ud83e\uddd8\ud83c\udffb\u200d\u2642\ufe0f, \ud83c\udf0d, \ud83c\udf5e, \ud83d\ude97, \ud83d\udcde, \ud83c\udf89, \u2764\ufe0f, \ud83c\udf46\", FileAnnotationType.HIGHLIGHT, Optional.empty()); final FileAnnotation expected = new FileAnnotation(\"lynyus\", LocalDateTime.of(2017, 5, 31, 15, 16, 1), 1, \"Hello\", FileAnnotationType.HIGHLIGHT, Optional.of(expectedLinkedAnnotation)); assertEquals(Collections.singletonList(expected), importer.importAnnotations(Path.of(\"src/test/resources/pdfs/minimal-emoji.pdf\"))); } }","title":"3.2 C\u00f3digo de Teste"},{"location":"v02/#4-resultados","text":"","title":"4. Resultados"},{"location":"v02/#41-resultados-dos-testes-jabref","text":"Na figura 01 temos o resultado dos testes da classe PdfAnnotationImporter. Podemos observar que dois testes n\u00e3o passaram. O primeiro teste que n\u00e3o passou foi produzido pela JabRef e ele errou, pois alterei o coment\u00e1rio esperado. Ent\u00e3o esse teste j\u00e1 era esperado em n\u00e3o passar. J\u00e1 o segundo teste foi projetado por mim e ser\u00e1 descuitdo logo adiante. Figura 01 - Resultado dos teste da classe PdfAnnotationImporter","title":"4.1 Resultados dos Testes JabRef"},{"location":"v02/#42-resultados-dos-meus-testes","text":"Para essa etapa do projeto preferi executar apenas dois testes novos. Em rela\u00e7\u00e3o aos ID 01 e 11.","title":"4.2 Resultados dos meus Testes"},{"location":"v02/#421-resultado-do-teste-id-01","text":"O teste do ID 01 j\u00e1 existia uma corbertura, por\u00e9m a corbertura s\u00f3 verificava se n\u00e3o abria outros formatos. Com isso, fique curioso para ver se ele n\u00e3o executava outro tipo de formato ent\u00e3o teste o formato .TXT. A partir da figura 02 podemos ver que o JabRef n\u00e3o consegue abrir um texto em formato .TXT o que era j\u00e1 esperado. Figura 02 - Resultado do Teste do ID 01","title":"4.2.1 Resultado do teste ID 01"},{"location":"v02/#422-resultado-do-teste-id-11","text":"O teste do ID 11 j\u00e1 n\u00e3o existia uma corbertura. Altere um PDF com um coment\u00e1rio para uma s\u00e9rie de Emoji (\ud83d\ude02, \ud83d\ude03, \ud83e\uddd8\ud83c\udffb\u200d\u2642\ufe0f, \ud83c\udf0d, \ud83c\udf5e, \ud83d\ude97, \ud83d\udcde, \ud83c\udf89, \u2764\ufe0f, \ud83c\udf46). A partir da figura 03 podemos ver que o teste n\u00e3o passou. N\u00e3o entendi o motivo do teste n\u00e3o ter passado, pelo o motivo da condi\u00e7\u00e3o ser um OU, sendo necess\u00e1rio apenas uma afirma\u00e7\u00e3o ser verdadeira. O arquivo consegue ser aberto ent\u00e3o, ou seja, j\u00e1 tenho uma condi\u00e7a6o verdadeira, o teste deveria ser passado j\u00e1 que Emoji n\u00e3o \u00e9 uma linguagem n\u00e3o comprendida pelo JabRef. Figura 03 - Resultado do Teste do ID 11","title":"4.2.2 Resultado do teste ID 11"},{"location":"v02/#versionamento","text":"Vers\u00e3o Data Modifica\u00e7\u00e3o Autor 1.0 05/10/2021 Cria\u00e7\u00e3o do site Ant\u00f4nio Ald\u00edsio 2.0 07/10/2021 Colocar os teste Ant\u00f4nio Ald\u00edsio","title":"Versionamento"}]}